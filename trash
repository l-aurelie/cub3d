//2d====== in castray
	//	draw_line(d->cam.x, d->cam.y, d->ray.hit_x , d->ray.hit_y, 0x00ff00, d);

void	display_2d(t_data *d)
{
	d->res.width = d->map.sq_size * d->map.width;
	d->res.heigth = d->map.sq_size * d->map.heigth;
	mlx_clear_window(d->ptr.mlx, d->ptr.window);
	ft_disp_map(d->map, d->ptr, d);
	disp_square(d->cam.x, d->cam.y, 0xffff00, d, 3);

	cast_rays(d);
	draw_line(d->cam.x, d->cam.y, (d->cam.x + cos(d->cam.rotate_angle) * 30), (d->cam.y + sin(d->cam.rotate_angle) * 30), 0x000000, d);
}

void	ft_disp_map(t_m map, t_p ptr, t_data *d)
{
	//printf("disp_map_____________\n");
	int i; 
	int j;
	int tileX;
	int tileY;

	i = 0;
	j = 0;
	while (j < map.heigth)
	{
		i = 0; 
		while (i < map.width)
		{
			tileX = i * map.sq_size;	
			tileY = j * map.sq_size;

			if (map.grid[j][i] == '1')
				disp_square(tileX, tileY, 0xffffff, d, map.sq_size);
			else
				disp_square(tileX, tileY, 0xff0000, d, map.sq_size);
			i++;
		}
		j++;
	}
}

void	draw_line(int x0, int y0, int x1, int y1, int color, t_data *d)
{
  int dx =  ft_abs (x1 - x0), sx = x0 < x1 ? 1 : -1;
  int dy = -ft_abs (y1 - y0), sy = y0 < y1 ? 1 : -1; 
  int err = dx + dy, e2; /* error value e_xy */
 
  for (;;){  /* loop */
			my_pixel_put(d, x0, y0, color);
	if (x0 == x1 && y0 == y1) break;
    e2 = 2 * err;
    if (e2 >= dy) { err += dy; x0 += sx; } /* e_xy+e_x > 0 */
    if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
  }
}

void	print_map(t_m map)
{
	int i;
	int j;

	i = 0; 
	j = 0;
	while (i < map.heigth)
	{	
		j = 0;
		while(j < map.width)
		{
			printf("%c", map.grid[i][j]);
			j++;
		}
		printf("\n");
		i++;
	}
}

/*void	disp_line(double a_x, double a_y, double b_x, double b_y, int color, t_p ptr)
{
	printf("disp_line\n");
	int x; 
	int y; 
	int m;//pente 
	int h;//origin ordonnee
	int y_max;
	int x_max;
	
	m = (b_y - a_y) / (b_x - a_x);
	h = a_y - (m * a_x);
	y = a_y;
	y_max = b_y;
	if(a_y > b_y)
	{
		y = b_y;	
		y_max = a_y;
	}
	while (y <= y_max)
	{
	//	printf("y = %f, x = %f\n", y, x);
	//	printf("m = %f, h = %f\n",m,h);

		x = a_x;
		x_max = b_x;
		if(a_y > b_y)
		{
			x = b_x;	
			x_max = a_x;
		}
		while (x <= x_max)
		{
		//printf("y = %f, x = %f\n", y, x);
		//		printf("m = %f, h = %f\n",m,h);
		//		printf("true = %d\n",y == (m * x) + h);
					if (y == (m * x) + h)
					mlx_pixel_put(ptr.mlx, ptr.window, x, y, color);
			x++;
		}
		y++;
	}
}*/

/*void	disp_line(int width, int heigth, int color, t_p ptr)
{
	int x;
	int y;
 
	y = 0; 
	while (y < heigth)
	{
		x = 0;
		while (x < width)
		{	
			if((3 * x) == y)
				mlx_pixel_put(ptr.mlx, ptr.window, x, y, color);
			x++;
		}
		y++;
	}
}*/
void    glbDrawLine(int firstx,int firsty,int lastx,int lasty, int color, t_d data)
{
    int         x1;        /* debut de la ligne => milieu de la ligne */
    int         y1;        /* debut de la ligne => milieu de la ligne */
    int         x2;        /* fin de la ligne => milieu de la ligne */
    int         y2;        /* fin de la ligne => milieu de la ligne */
    int         dx;        /* longueur X de la droite */ 
    int         dy;        /* longueur Y de la droite */ 
    int         sub;        /* utilise pour des soustractions */
    int         remain;        /* nombre de pixel restant */
    int         error;        /* erreur du trace, doit etre corrige si positif */
    int         inc1;        /* pour des incrementations/decrementations */
    int         inc2;        /* pour des incrementations/decrementations */

    if (firstx>lastx)
    {
        x1=lastx;
        x2=firstx;
        y1=lasty;
        y2=firsty;
    }
    else
    {
        x1=firstx;
        x2=lastx;
        y1=firsty;
        y2=lasty;
    }
    dx=x2-x1;    /* longueur X de la droite */ 
    dy=y2-y1;    /* longueur Y de la droite */ 
    if ((!dx)&&(!dy)) return; /* quitte si aucun trace a effectuer */
    if (dy<0) 
    {
        dy=-dy;
        inc1=-1;
        inc2=1;
    }
    else 
    {
        inc1=1;
        inc2=1;
    }

    if (dx>dy)
    {   
        sub=dx-dy;          
        error=dy-(dx>>1);       
        remain=(dx+1)>>1;    
        do
        {
			my_mlx_pixel_put(data, x1, y1, color);
			my_mlx_pixel_put(data, x2, y2, color);
            x1+=inc2;    /* la position x1 augmente */
            x2-=inc2;   /* et la position x2 diminue (on va vers le centre) */
            if (error>=0)    /* si l'erreur est assez grande pour etre corrigee */
            {
                y1+=inc1;    /* la position y1 augmente */
                y2-=inc1;    /* et la position y2 diminue (on va vers le centre) */
                error-=sub;    /* diminue l'erreur */
            }
            else error+=dy;    /* sinon augmente l'erreur */
        } while (--remain>0);    /* diminue remain et recommence s'il reste des points a tracer */
        if (!(dx&1)) my_mlx_pixel_put(data, x1, y1, color); 
        return;        /* fin de la fonction */
    }
    else
    {   
        sub=dy-dx;
        error=dx-(dy>>1);
        remain=(dy+1)>>1;
        do
        {
			my_mlx_pixel_put(data, x1, y1, color);
            my_mlx_pixel_put(data, x2, y2, color);
            y1+=inc2;    /* la position y1 augmente */
            y2-=inc2;   /* et la position y2 diminue (on va vers le centre) */
            if (error>=0)    /* si l'erreur est assez grande pour etre corrigee */
            {
                x1+=inc2;    /* la position x1 augmente */
                x2-=inc2;    /* et la position x2 diminue (on va vers le centre) */
                error-=sub;    /* diminue l'erreur */
            }
            else error+=dx;    /* sinon augmente l'erreur */
        } while (--remain>0);    /* diminue remain et recommence s'il reste des points a tracer */
        if (!(dy&1)) my_mlx_pixel_put(data, x1, y1, color);
        return;        /* fin de la fonction */
    }
}

